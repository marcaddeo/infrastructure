---
apiVersion: fluxcd.controlplane.io/v1
kind: ResourceSet
metadata:
  name: secret-composer
  namespace: utilities
  annotations:
    fluxcd.controlplane.io/reconcile: enabled
    fluxcd.controlplane.io/reconcileEvery: 30m
    fluxcd.controlplane.io/reconcileTimeout: 5m
spec:
  resources:
    - apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: secret-composer-sa
        namespace: << inputs.namespace >>
    - apiVersion: rbac.authorization.k8s.io/v1
      kind: Role
      metadata:
        name: secret-composer-role
        namespace: << inputs.namespace >>
        rules:
          - apiGroups:
              - ""
            resources:
              - configmaps
              - secrets
            verbs:
              - get
              - list
              - watch
          - apiGroups:
              - ""
            resources:
              - secrets
            verbs:
              - create
              - update
              - patch
              - delete
    - apiVersion: rbac.authorization.k8s.io/v1
      kind: RoleBinding
      metadata:
        name: secret-composer-binding
        namespace: << inputs.namespace >>
      subjects:
        - kind: ServiceAccount
          name: secret-composer-sa
      roleRef:
        kind: Role
        name: secret-composer-role
        apiGroup: rbac.authorization.k8s.io
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: secret-composer-script
        namespace: << inputs.namespace >>
      data:
        secret-composer.sh: |
          #!/usr/bin/env bash
          set -euo pipefail

          trap 'error "Error on line $LINENO. Last command: $BASH_COMMAND"' ERR

          readonly JQ_EXTRACT_MAPPINGS='(.data // {}) | to_entries
            | map(select(.key | startswith("map.")))
            | map({key: .key | sub("map\\.";""), value: .value})
            | from_entries'

          readonly JQ_EXTRACT_GENERATORS='(.data // {}) | keys[]
            | select(startswith("gen."))
            | sub("gen\\.";"")'

          readonly JQ_BUILD_SECRET='
            .data = (.data // {}) |
            .metadata = {
              "name": $ARGS.named.target,
              "namespace": $ARGS.named.namespace,
              "annotations": {
                "secret-composer.controller/managed": "true"
              },
              "ownerReferences": [{
                "apiVersion": "v1",
                "kind": "ConfigMap",
                "name": $ARGS.named.name,
                "uid": $ARGS.named.uid,
                "blockOwnerDeletion": true,
                "controller": true
              }]
            } |
            reduce ($mappings | to_entries[]) as $item (.; .data[$item.key] = .data[$item.value]) |
            reduce ($generators | to_entries[]) as $item (.; .data[$item.key] = $item.value) |
            reduce ($mappings | to_entries[]) as $item (.; if $item.key != $item.value then del(.data[$item.value]) else . end) |
            .data |= with_entries(select(.value != null))
          '

          info() {
            echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] $1"
          }

          warn() {
            echo "$(date '+%Y-%m-%d %H:%M:%S') [WARN] $1" >&2
          }

          error() {
            echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] $1" >&2
          }

          check_dependencies() {
            local dependencies=(jq kubectl openssl)

            for dep in "${dependencies[@]}"; do
              if ! command -v "$dep" &>/dev/null; then
                error "'$dep' is required but not installed."

                exit 1
              fi
            done
          }

          get_namespace() {
            if [[ -n "${CURRENT_NAMESPACE:-}" ]]; then
              echo "$CURRENT_NAMESPACE"
            elif [[ -f /var/run/secrets/kubernetes.io/serviceaccount/namespace ]]; then
              cat /var/run/secrets/kubernetes.io/serviceaccount/namespace
            else
              echo "default"
            fi
          }

          resolve_generators() {
            local namespace="$1"
            local target_secret="$2"
            local generators="$3"

            if [[ -z "$generators" ]]; then
              echo "{}"

              return
            fi

            local generated="{}"
            local target="$(kubectl get secret "$target_secret" -n "$namespace" -o json 2>/dev/null || echo "{}")"

            for key in $generators; do
              local value="$(echo "$target" | jq -r --arg key "$key" '.data[$key] // empty')"

              if [[ -z "$value" ]]; then
                value="$(openssl rand -base64 32 | tr -d '\n' | base64)"
              fi

              generated="$(echo "$generated" | jq -c --arg key "$key" --arg value "$value" '.[$key] = $value')"
            done

            echo "$generated"
          }

          apply_if_changed() {
            local namespace="$1"
            local target_secret="$2"
            local new_secret="$3"

            local current_secret="$(kubectl get secret "$target_secret" -n "$namespace" -o json 2>/dev/null || true)"

            if [[ -n "$current_secret" ]]; then
              if echo "$current_secret" | jq -e --argjson new_secret "$new_secret" '.data == $new_secret.data' &>/dev/null; then
                info "No changes detected."

                return 0
              fi
            fi

            if echo "$new_secret" | kubectl apply -f - &>/dev/null; then
              info "Synced successfully."
            else
              error "Failed to apply changes."

              return 1
            fi
          }

          process_item() {
            local item="$1"
            local namespace="$2"

            local metadata="$(echo "$item" | jq -r '[.metadata.name, .metadata.uid, (.data.sourceSecret // ""), (.data.targetSecret // "")] | @tsv')"

            local name uid src target
            IFS=$'\t' read -r name uid src target <<<"$metadata"

            if [[ -z "$src" || -z "$target" ]]; then
              warn "Skipping '$name': Missing source or target definition."

              return 0
            fi

            info "Syncing '$name': $src -> $target"

            local source_secret
            if ! source_secret="$(kubectl get secret "$src" -n "$namespace" -o json 2>/dev/null)"; then
              warn "Source '$src' not found. Waiting..."

              return 0
            fi

            local mappings="$(echo "$item" | jq -c "$JQ_EXTRACT_MAPPINGS" || echo "{}")"
            local generators="$(echo "$item" | jq -r "$JQ_EXTRACT_GENERATORS" || echo "")"
            local generated="$(resolve_generators "$namespace" "$target" "$generators")"

            local new_secret="$(
              echo "$source_secret" | jq -c \
                --arg target "$target" \
                --arg namespace "$namespace" \
                --arg name "$name" \
                --arg uid "$uid" \
                --argjson mappings "$mappings" \
                --argjson generators "$generated" \
                "$JQ_BUILD_SECRET"
            )"

            apply_if_changed "$namespace" "$target" "$new_secret"
          }

          main() {
            check_dependencies

            local namespace="$(get_namespace)"

            info "Starting discovery in namespace: $namespace"

            local config_maps="$(kubectl get configmaps -n "$namespace" -l secret-composer.controller/enabled=true -o json | jq -c '.items[]')"

            if [[ -z "$config_maps" ]]; then
              info "No configurations found."

              return 0
            fi

            local -a items
            readarray -t items <<<"$config_maps"

            for item in "${items[@]}"; do
              process_item "$item" "$namespace"
            done
          }

          main "$@"
    - apiVersion: batch/v1
      kind: CronJob
      metadata:
        name: secret-composer-controller
        namespace: << inputs.namespace >>
      spec:
        schedule: << inputs.cron_schedule >>
        successfulJobsHistoryLimit: 1
        failedJobsHistoryLimit: 1
        concurrencyPolicy: Forbid
        jobTemplate:
          spec:
            template:
              spec:
                serviceAccountName: secret-composer-sa
                restartPolicy: OnFailure
                containers:
                  - name: controller
                    image: bitnami/kubectl:latest
                    command: ["/bin/bash", "/scripts/secret-composer.sh"]
                    env:
                      - name: CURRENT_NAMESPACE
                        valueFrom:
                          fieldRef:
                            fieldPath: metadata.namespace
                    resources:
                      requests:
                        cpu: 10m
                        memory: 32Mi
                      limits:
                        cpu: 200m
                        memory: 128Mi
                    volumeMounts:
                      - name: scripts
                        mountPath: /scripts
                volumes:
                  - name: scripts
                    configMap:
                      name: secret-composer-script
                      defaultMode: 0755
