---
apiVersion: v1
kind: ConfigMap
metadata:
  name: oauth2-proxy-sync-config
  namespace: flux-system
  labels:
    secret-sync.controller/enabled: "true"
data:
  sourceSecret: oidc-provider-secret
  targetSecret: oauth2-proxy-secret

  map.client-id: client-id
  map.client-secret: client-secret

  gen.cookie-secret: "true"
# --- 1. RBAC: Permissions for this Namespace Only ---
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: secret-sync-sa
  namespace: flux-system # <--- CHANGE THIS PER NAMESPACE
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-sync-role
  namespace: flux-system # <--- CHANGE THIS PER NAMESPACE
rules:
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "create", "patch", "update", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: secret-sync-binding
  namespace: flux-system # <--- CHANGE THIS PER NAMESPACE
subjects:
  - kind: ServiceAccount
    name: secret-sync-sa
roleRef:
  kind: Role
  name: secret-sync-role
  apiGroup: rbac.authorization.k8s.io
---
# --- 2. THE CONTROLLER: CronJob Loop ---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: secret-sync-controller
  namespace: flux-system # <--- CHANGE THIS PER NAMESPACE
spec:
  schedule: "* * * * *"
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: secret-sync-sa
          restartPolicy: OnFailure
          containers:
            - name: controller
              image: bitnami/kubectl:latest
              command: ["/bin/bash", "-c"]
              args:
                - |
                  set -euo pipefail

                  # --- CONFIGURATION ---
                  # The label we look for to activate sync logic
                  TRIGGER_LABEL="secret-sync.controller/enabled=true"

                  # --- RUNTIME ---
                  NS=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
                  echo "--- Running in Namespace: $NS ---"

                  # 1. DISCOVER
                  CONFIGS=$(kubectl get configmaps -n "$NS" -l $TRIGGER_LABEL -o json)
                  COUNT=$(echo "$CONFIGS" | jq '.items | length')

                  if [[ "$COUNT" -eq 0 ]]; then
                    echo "No sync configs found."
                    exit 0
                  fi

                  for ((i=0; i<COUNT; i++)); do
                    ITEM=$(echo "$CONFIGS" | jq ".items[$i]")
                    NAME=$(echo "$ITEM" | jq -r ".metadata.name")

                    # Capture UID for Owner Reference (Garbage Collection)
                    CM_UID=$(echo "$ITEM" | jq -r ".metadata.uid")

                    # Extract Standard Fields
                    SRC=$(echo "$ITEM" | jq -r ".data.sourceSecret // empty")
                    TGT=$(echo "$ITEM" | jq -r ".data.targetSecret // empty")

                    if [[ -z "$SRC" || -z "$TGT" ]]; then
                       echo "Skipping '$NAME': Missing sourceSecret or targetSecret."
                       continue
                    fi

                    echo "Syncing '$NAME': $SRC -> $TGT"

                    # 2. EXTRACT MAPS (Prefix: map.)
                    # logic: { key: "TargetKey", value: "SourceKey" }
                    KEYS=$(echo "$ITEM" | jq -c '
                      .data | to_entries
                      | map(select(.key | startswith("map.")))
                      | map({key: .key | sub("map.";""), value: .value})
                      | from_entries'
                    )

                    # 3. EXTRACT GENERATORS (Prefix: gen.)
                    GEN_KEYS_LIST=$(echo "$ITEM" | jq -r '
                      .data | keys[] | select(startswith("gen.")) | sub("gen.";"")'
                    )

                    # --- SYNC LOGIC ---

                    # A. Handle Generated Keys (Idempotent)
                    TGT_JSON=$(kubectl get secret "$TGT" -n "$NS" -o json 2>/dev/null || true)
                    GEN_JSON="{}"

                    for key in $GEN_KEYS_LIST; do
                      EXISTING=""
                      if [[ -n "$TGT_JSON" ]]; then
                        EXISTING=$(echo "$TGT_JSON" | jq -r --arg k "$key" '.data[$k] // empty')
                      fi

                      if [[ -n "$EXISTING" ]]; then
                         VAL="$EXISTING"
                      else
                         # Generate 32-char Alphanumeric -> Base64
                         RAW=$(LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 32)
                         VAL=$(echo -n "$RAW" | base64 | tr -d '\n')
                      fi
                      GEN_JSON=$(echo "$GEN_JSON" | jq -c --arg k "$key" --arg v "$VAL" '.[$k] = $v')
                    done

                    # B. Get Source
                    SRC_JSON=$(kubectl get secret "$SRC" -n "$NS" -o json 2>/dev/null || true)
                    if [[ -z "$SRC_JSON" ]]; then
                      echo "  Source '$SRC' missing. Waiting..."
                      continue
                    fi

                    # C. Build Proposed Secret
                    # Includes OwnerReference so deleting the ConfigMap deletes the Secret
                    PROPOSED=$(echo "$SRC_JSON" | jq -c --arg name "$TGT" \
                                         --arg ns "$NS" \
                                         --arg cm_name "$NAME" \
                                         --arg cm_uid "$CM_UID" \
                                         --argjson map "$KEYS" \
                                         --argjson gen "$GEN_JSON" '
                      .metadata = {
                        "name": $name,
                        "namespace": $ns,
                        "annotations": { "secret-sync.controller/managed": "true" },
                        "ownerReferences": [{
                           "apiVersion": "v1",
                           "kind": "ConfigMap",
                           "name": $cm_name,
                           "uid": $cm_uid,
                           "blockOwnerDeletion": true,
                           "controller": true
                        }]
                      } |

                      # 1. Map Keys (Source -> Target)
                      reduce ($map | to_entries[]) as $i (.; .data[$i.key] = .data[$i.value]) |

                      # 2. Inject Generated Keys
                      reduce ($gen | to_entries[]) as $i (.; .data[$i.key] = $i.value) |

                      # 3. Clean Unused Source Keys
                      reduce ($map | to_entries[]) as $i (.; if $i.key != $i.value then del(.data[$i.value]) else . end) |

                      # 4. SAFETY: Remove nulls (if source key was missing)
                      .data |= with_entries(select(.value != null))
                    ')

                    # D. Apply
                    if [[ -z "$TGT_JSON" ]] || ! echo "$TGT_JSON" | jq -e --argjson new "$PROPOSED" '.data == $new.data' >/dev/null; then
                       echo "$PROPOSED" | kubectl apply -f -
                       echo "  Synced successfully."
                    fi
                  done
